%!TeX root=miden_lattices.tex
\section{Fast arithmetic in cyclotomic rings}

\subsubsection{Parameter sets}

The lattice based schemes Kyber, Saber, Falcon and Dilithium, which are all finalists in the NIST pqcrypto standardization
effort (and many other schemes), all rely on arithmetic in cyclotomic rings of the form
\[  R_{q,n} = \Z_q[x]/(x^n + 1)    \]
for some modulus $q$ (not necessarily prime) and $n = 2^k$, and more in particular $n = 256, 512, 1024$.
The moduli used by the different schemes are as follows:
\bit
\item Kyber: $q = 3329$
\item Saber: $q = 2^{13}$
\item Falcon: $q = 12289$
\item Dilithium: $q = 2^{23} - 2^{13} + 1$
\eit

When the modulus $q$ is chosen such that $2n | \varphi(q)$ (in many cases $q$ is a prime so then $2n | q-1$), 
it is well known that arithmetic in $R_q$ can be computed efficiently using the number theoretic transform.
This can be done natively for Falcon and Dilithium, almost natively for Kyber and with a work-around for Saber.

In Miden, the native modulus is $p = 2^{64} - 2^{32} + 1$, so $\Z_q$ in this case contains a root of unity 
of order $2^{32}$ and in particular of order $2^k$ for any $k = 1, \ldots, 32$, and we therefore get native
arithmetic in $R_{p,n}$ for all such $n = 2^k$.

\subsubsection{Bound on the size of $q$}

Since the $q$ used in the above schemes is different from the native $p$, we first need to give a bound for
the maximum modulus size $q$ for each ring $R_{q,n}$ such that we can recover the product exactly (using 
an extra modular reduction) from the product in $R_{p,n}$.

So assume we are given two elements  $a(x), b(x) \in R_{q,n}$ written as $a(x) = \sum_{i = 0}^{n-1} a_i x^i$
and $b(x) = \sum_{i = 0}^{n-1} b_i x^i$, then the product $c(x) = \sum_{i = 0}^{n-1} c_i x^i$ satisfies
\[  c_i = \sum_{j = 0}^{i} a_{i -j} b_j  - \sum_{j = i+1}^{n-1} a_{n-j+i} b_{j}  \, . \]
In particular, we have a sum of $n$ products of elements
in $\Z_q$ (with $\pm$), so we see that the maximum bound on $c_i$ is given 
\[ |c_i| < n q^2 \, , \]
assuming that all coefficients were represented in $[0,q)$.  If a symmetric interval $[q/2, q/2)$ was used to 
represent elements in $R_{q, n}$ the bound is clearly sufficient as well.  
Since we need to be able to recover this as an integer (it can be negative) to be able to reduce modulo $q$ afterwards,
it suffices that $p \geq 2 n q^2$.  For popular choices of $n$ above we therefore obtain the following upper bounds:
\begin{center}
\begin{tabular}{|c|c|}
\hline
$n$ & $\max \log_2(q)$ \\
\hline
$256$ &  27.5 \\
$512$ &   27 \\
$1024$ &   26.5 \\
\hline
\end{tabular}
\end{center}

\subsubsection{Lazy reduction} In the schemes that use a module structure such as Kyber, Saber and Dilithium, 
one often has to compute 
a matrix vector product $\bA \cdot \bv$ where the matrix and vector contain elements of $R_{q,n}$.
Assuming that the matrix has $\ell$ columns, we therefore could add $\ell$ such products together before
doing the final reduction modulo $q$.  The addition of $\ell$ such products simply introduces an extra 
factor of $\ell$ in the above bound.  The largest number of columns appearing in all of the above schemes
is $7$ in the case of Dilithium level 5 parameter set.  It is easy to verify that for this case we have
$p > 7 \cdot 2 \cdot 256 \cdot q^2$, so we can indeed postpone the final reduction after the addition 
of the $\ell$ products.

\subsubsection{Multiplication using NTT}

Let $N$ be a power of $2$ and assume that $q-1 \equiv 0 \bmod 2N$, and let $\psi$ be a primitive $2N$-th root 
of unity and $\omega = \psi^2$ a primitive $N$-th root of unity.  The $N$-point NTT of a sequence 
$[a[0], \ldots, a[N-1]]$ is denoted as $\tilde{a} = NTT(a)$ and defined by $\tilde{a}[i] = \sum_{j = 0}^{N-1} a[j] \omega^{i j}$
for $i = 0, \ldots, n-1$.  The inverse transformation $b = INTT(\tilde{a})$ is given by 
$b[i] = \frac{1}{N} \sum_{j = 0}^{N-1} a[j] \omega^{-i j}$, which can be computed by replacing $\omega$ 
by $\omega^{-1}$ and scaling by $N$.

Since $\omega$ is an $N$-th root of unity, note that this also corresponds to the evaluation 
of the polynomial $a(x) \in \Z_q[x]/(x^N - 1)$ in $\omega$, and as such we can multiply two 
polynomials in $a(x), b(x) \in \Z_q[x]/(x^N - 1)$ by computing
\[  c(x) = INTT(NTT(a) \cdot NTT(b)  \]
where $\cdot$ denotes pointwise multiplication.

The standard approach to NTT is given in Algorithm~\ref{algo:ntt1} where BitReverse
computes an array $A$ such that $A[k] = a[BitReverse(k)]$ obtained by reversing
the binary expansion of $k$ using $b = \log_2(N)$ bits to write $k$.
In particular, if $k = k_0 \ldots k_{b-1}$ then $BitReverse(k) = k_{b-1} \ldots k_0$. 
\begin{algorithm}[!t] \label{algo:ntt1}
\begin{scriptsize}
\caption{\emph{Iterative NTT}}
\KwIn{Polynomial $a(x) \in \mathbb{Z}_q[\mathbf{x}]$ of
degree $N-1$ and $N$-th primitive root $\omega_N \in \mathbb{Z}_q$ of unity}
\KwOut{Polynomial $A(x) \in \mathbb{Z}_q[\mathbf{x}]$ = NTT($a$)}
\Begin{
\everypar={\nl}
$A \leftarrow BitReverse(a)$;

\For{$m=2$ to $N$ by $m=2m$}
{
$\omega_m \leftarrow \omega_N^{N/m}$ \;

$\omega \leftarrow 1$ \;

\For{$j=0$ to $m/2-1$}
{
\For{$k=0$ to $N-1$ by $m$}
{

$t \leftarrow \omega \cdot A[k+j+m/2]$ \;
$u \leftarrow A[k+j]$ \;
$A[k+j] \leftarrow u+t \bmod q$ \;
$A[k+j+m/2] \leftarrow u-t \bmod q$ \;
}
$\omega \leftarrow \omega \cdot \omega_m$ \;
}
}
}
\end{scriptsize}
\end{algorithm} 


The above however is not directly applicable since we need arithmetic in the ring $\Z_q[x]/(x^N+1)$.
Note that the roots of $x^N+1$ are given by $\psi^{2k + 1}$ for $k = 0, \ldots, n-1$, so we would 
need to compute the evalutions of $a(x)$ in those powers.  Since $\psi^{2k + 1} = \omega^k \psi$, 
so we could use the standard NTT above on the scaled polynomial $a(\psi x)$, and we would obtain
\[  c(\psi x) =    INTT(NTT(a(\psi x)) \cdot NTT(b(\psi x))   \, . \]
This requires scaling of $a(x), b(x)$ and an inverse scaling of $c(\psi x)$, where the latter could be 
combined with the scaling by $N$ in the final step of the INTT.

\subsubsection{Optimizing the NTT}

To optimize the NTT, it is possible to absorb the scaling by $\psi$ and also to work around 
the BitReverse as is done in \cite{longa}.  In the forward NTT, the function will return a $\psi$-scaled NTT
in bit-reverse order, which will be undone in the INTT.

Let $NTT_{sb}$ denote the function which computes the NTT of the scaled polynomial $a(\psi x)$ and where the output 
is given in bit-reversed order, in particular the output is given by 
\[  BitReverse(  [a(\psi \omega^{k}) : k \in [0 \ldots N-1]]   ) \, .  \]
The resulting algorithm is given in Algorithm~\ref{algo:ntt_sb} and $\Psi_{rev}$ is the 
array given by 
\[ \Psi_{rev} = BitReverse( [ \psi^{k}) : k \in [0 \ldots N-1]] ) \, . \]

\begin{algorithm}[!t] \label{algo:ntt_sb}
\begin{scriptsize}
\caption{\emph{$NTT_{sb}$}}
\KwIn{A vector $a = [a[0], \ldots, a[N-1]]$ of elements in $\Z_q$ in standard order 
and $2N$-th primitive root $\psi \in \mathbb{Z}_q$ of unity, and 
precomputed table $\Psi_{rev}$ containing the powers of $\psi$ in bit-reversed order}
\KwOut{$NTT_{sb}$($a$), i.e.\ bit-reversed NTT of scaled $a(\psi x)$}
\Begin{
\everypar={\nl}
$t = n$

\For{$m = 1; m < n; m = 2m$} 
{
$t = t/2$

\For{$i = 0; i < m; i++$} 
{
$j1 = 2 \cdot i \cdot t$

$j2 = j1 + t - 1$

$S = \Psi_{rev}[m + i]$

\For{$j = j1; j \le j2; j++$} 
{
$U = a[j]$

$V = a[j + t] \cdot S$

$a[j] = U + V \bmod q$

$a[j + t] = U - V \bmod q$
}
}
}
}
\end{scriptsize}
\end{algorithm} 

Let $INTT_{sb}$ denote the function which computes the inverse NTT of a bit-reversed array 
including scaling by $\psi^-1$, i.e.\ $INTT_{sb}$ satisfies
\[ INTT_{sb} (NTT_{sb}(a(x)) = a(x) \, . \]
Similarly as for $NTT_{sb}$ it uses an array $\Psi^-1_{rev}$ of powers of $\psi^{-1}$ in bit-reversed order
\[ \Psi^{-1}_{rev} = BitReverse( [ \psi^{-k}) : k \in [0 \ldots N-1]] ) \, . \]

\begin{algorithm}[!t] \label{algo:intt_sb}
\begin{scriptsize}
\caption{\emph{$INTT_{sb}$}}
\KwIn{A vector $a = [a[0], \ldots, a[N-1]]$ of elements in $\Z_q$ in standard order 
and $2N$-th primitive root $\psi \in \mathbb{Z}_q$ of unity, and 
precomputed table $\Psi^{-1}_{rev}$ containing the powers of $\psi^{-1}$ in bit-reversed order}
\KwOut{$INTT_{sb}$($a$) in standard ordering}
\Begin{
\everypar={\nl}
$t = 1$

\For {$m = N; m > 1; m = m/2$}
{
$j1 = 0$

$h = m/2$

\For {$i = 0; i < h; i++$}
{
$j2 = j1 + t - 1$

$S = \Psi^{-1}_{rev}[h + i]$

\For {$j = j1; j \le j2; j++$}
{
$U = a[j]$

$V = a[j + t]$

$a[j] = U + V \bmod q$

$a[j + t] = (U - V ) \cdot S \bmod q$
}
$j1 = j1 + 2t$
}
$t = 2t$
}
\For {$j = 0; j < N; j++$} 
{
$a[j] = a[j] \cdot N^{-1} \bmod q$
}
}
\end{scriptsize}
\end{algorithm} 

To compute the product $c(x)$ of two polynomials in $a(x), b(x) \in \Z_q[x]/(x^N+1)$, we can now simply it as 
\[  c(x) = INTT_{sb}(NTT_{sb}(a(x)) \cdot NTT_{sb}(b(x)) \, . \]

The function $NTT_{sb}$ uses $N/2 \log_2(N)$ multiplications modulo $q$ and a total of $N \log_2(N)$ additions/subtractions modulo $q$.
Due to the final scaling, the function $INTT_{sb}$ requires $N/2 \log_2(N) + N$ multiplications modulo $q$ and 
$N \log_2(N)$ additions/subtractions modulo $q$.

A polynomial product in $\Z_q[x]/(x^N+1)$ therefore requires $3N/2 \log_2(N) + N$ multiplications and $3 N \log_2(N)$ 
additions/subtractions.  This should be compared to the $N^2$ multiplications and additions required for schoolbook multiplication.

Example: for $N = 256$ we thus require 3328 multiplications modulo $q$ and 6144 additions modulo $q$ compared to the 
65536 multiplications/additions for the schoolbook approach.

